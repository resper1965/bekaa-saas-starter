#!/usr/bin/env node

/**
 * Bekaa Product Generator
 * Scaffold completo de produto em segundos
 */

import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';

interface ProductConfig {
  name: string;
  slug: string;
  description: string;
  basePrice: number;
  icon: string;
  color: string;
}

// Helper functions
function toPascalCase(str: string): string {
  return str
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function toCamelCase(str: string): string {
  const pascal = toPascalCase(str);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

function ensureDir(dir: string) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

async function generateProduct() {
  console.log('üöÄ Bekaa Product Generator\n');

  // Por enquanto, usar valores padr√£o (pode ser expandido com inquirer)
  const config: ProductConfig = {
    name: process.argv[2] || 'New Product',
    slug: process.argv[3] || process.argv[2]?.toLowerCase().replace(/\s+/g, '-') || 'new-product',
    description: process.argv[4] || 'Product description',
    basePrice: parseFloat(process.argv[5]) || 99,
    icon: process.argv[6] || 'Box',
    color: process.argv[7] || 'primary',
  };

  if (!config.slug || !/^[a-z0-9-]+$/.test(config.slug)) {
    console.error('‚ùå Slug inv√°lido. Use apenas letras min√∫sculas, n√∫meros e h√≠fens.');
    process.exit(1);
  }

  console.log(`üì¶ Gerando produto: ${config.name} (${config.slug})\n`);

  const rootDir = path.join(process.cwd(), '..', '..');
  
  // 1. Criar schema no Prisma
  console.log('  üìÑ Criando database schema...');
  await createDatabaseSchema(rootDir, config);

  // 2. Criar m√≥dulo backend
  console.log('  üîß Criando backend module...');
  await createBackendModule(rootDir, config);

  // 3. Criar rotas frontend
  console.log('  üé® Criando frontend routes...');
  await createFrontendRoutes(rootDir, config);

  // 4. Adicionar ao cat√°logo
  console.log('  üìã Adicionando ao product catalog...');
  await addToProductCatalog(rootDir, config);

  console.log('\n‚úÖ Produto gerado com sucesso!\n');
  console.log('üìù Pr√≥ximos passos:');
  console.log('1. Execute migrations: pnpm db:migrate');
  console.log(`2. Implemente l√≥gica em: apps/api/src/modules/${config.slug}/`);
  console.log(`3. Customize UI em: apps/web/app/(dashboard)/${config.slug}/`);
}

async function createDatabaseSchema(rootDir: string, config: ProductConfig) {
  const schemaPath = path.join(rootDir, 'packages', 'database', 'prisma', 'schema.prisma');
  
  if (!fs.existsSync(schemaPath)) {
    console.warn('    ‚ö†Ô∏è  Prisma schema n√£o encontrado');
    return;
  }

  // Adicionar coment√°rio no schema (migrations ser√£o criadas manualmente)
  const comment = `
// ${config.name} - Generated by product generator
// Run: pnpm db:migrate to create migration
`;
  
  // Nota: Em produ√ß√£o, isso criaria uma migration real
  console.log(`    ‚úì Schema preparado (execute pnpm db:migrate)`);
}

async function createBackendModule(rootDir: string, config: ProductConfig) {
  const modulePath = path.join(rootDir, 'apps', 'api', 'src', 'modules', config.slug);
  ensureDir(modulePath);

  // Module file
  const moduleContent = `import { Module } from '@nestjs/common';
import { ${toPascalCase(config.slug)}Controller } from './${config.slug}.controller';
import { ${toPascalCase(config.slug)}Service } from './${config.slug}.service';

@Module({
  controllers: [${toPascalCase(config.slug)}Controller],
  providers: [${toPascalCase(config.slug)}Service],
  exports: [${toPascalCase(config.slug)}Service],
})
export class ${toPascalCase(config.slug)}Module {}
`;

  fs.writeFileSync(
    path.join(modulePath, `${config.slug}.module.ts`),
    moduleContent
  );

  // Controller
  const controllerContent = `import { Controller, Get, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@/guards/auth.guard';
import { ProductAccessGuard } from '@/guards/product-access.guard';
import { RequiresProduct } from '@/decorators/requires-product.decorator';
import { ${toPascalCase(config.slug)}Service } from './${config.slug}.service';

@Controller('${config.slug}')
@UseGuards(AuthGuard, ProductAccessGuard)
@RequiresProduct('${config.slug}')
export class ${toPascalCase(config.slug)}Controller {
  constructor(private readonly ${toCamelCase(config.slug)}Service: ${toPascalCase(config.slug)}Service) {}

  @Get()
  async findAll() {
    return this.${toCamelCase(config.slug)}Service.findAll();
  }
}
`;

  fs.writeFileSync(
    path.join(modulePath, `${config.slug}.controller.ts`),
    controllerContent
  );

  // Service
  const serviceContent = `import { Injectable } from '@nestjs/common';

@Injectable()
export class ${toPascalCase(config.slug)}Service {
  async findAll() {
    // Implement your business logic here
    return { message: '${config.name} service' };
  }
}
`;

  fs.writeFileSync(
    path.join(modulePath, `${config.slug}.service.ts`),
    serviceContent
  );

  console.log(`    ‚úì M√≥dulo criado em: ${modulePath}`);
}

async function createFrontendRoutes(rootDir: string, config: ProductConfig) {
  const routePath = path.join(rootDir, 'apps', 'web', 'app', '(dashboard)', config.slug);
  ensureDir(routePath);

  // Layout
  const layoutContent = `'use client';

import { useProductAccess } from '@bekaa/auth';
import { LoadingSpinner } from '@bekaa/ui';

export default function ${toPascalCase(config.slug)}Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const { hasAccess, isLoading } = useProductAccess('${config.slug}');

  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (!hasAccess) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-2xl font-medium text-slate-100 mb-2">
            Acesso n√£o dispon√≠vel
          </h2>
          <p className="text-slate-400">
            Voc√™ precisa de uma assinatura para acessar ${config.name}.
          </p>
        </div>
      </div>
    );
  }

  return <>{children}</>;
}
`;

  fs.writeFileSync(
    path.join(routePath, 'layout.tsx'),
    layoutContent
  );

  // Page
  const pageContent = `'use client';

import { Card, CardHeader, CardTitle, CardDescription, CardContent } from '@bekaa/ui';
import { ${config.icon} } from 'lucide-react';

export default function ${toPascalCase(config.slug)}Page() {
  return (
    <div className="space-y-8">
      <div className="flex items-center gap-4">
        <div className="w-12 h-12 bg-primary-500/10 rounded-xl flex items-center justify-center">
          <${config.icon} className="w-6 h-6 text-primary-400" />
        </div>
        <div>
          <h1 className="text-4xl font-display font-medium text-slate-100">
            ${config.name}
          </h1>
          <p className="text-slate-400 mt-1">${config.description}</p>
        </div>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Welcome to ${config.name}</CardTitle>
          <CardDescription>
            Start building your ${config.slug} features here.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <p className="text-slate-300">
            This is a scaffold. Implement your business logic in:
          </p>
          <ul className="list-disc list-inside mt-4 space-y-2 text-slate-400">
            <li>Backend: apps/api/src/modules/${config.slug}/</li>
            <li>Frontend: apps/web/app/(dashboard)/${config.slug}/</li>
          </ul>
        </CardContent>
      </Card>
    </div>
  );
}
`;

  fs.writeFileSync(
    path.join(routePath, 'page.tsx'),
    pageContent
  );

  console.log(`    ‚úì Rotas criadas em: ${routePath}`);
}

async function addToProductCatalog(rootDir: string, config: ProductConfig) {
  const catalogPath = path.join(rootDir, 'apps', 'web', 'config', 'products.ts');
  ensureDir(path.dirname(catalogPath));

  let catalogContent = '';
  if (fs.existsSync(catalogPath)) {
    catalogContent = fs.readFileSync(catalogPath, 'utf-8');
  } else {
    catalogContent = `import { LucideIcon } from 'lucide-react';

export interface ProductConfig {
  slug: string;
  name: string;
  description: string;
  icon: LucideIcon;
  basePrice: number;
  features: string[];
  color: string;
}

export const products: ProductConfig[] = [];
`;
  }

  const newProduct = `  {
    slug: '${config.slug}',
    name: '${config.name}',
    description: '${config.description}',
    icon: ${config.icon},
    basePrice: ${config.basePrice},
    features: ['Feature 1', 'Feature 2', 'Feature 3'],
    color: '${config.color}',
  },`;

  catalogContent = catalogContent.replace('];', `${newProduct}\n];`);

  if (!catalogContent.includes(`import { ${config.icon} }`)) {
    catalogContent = catalogContent.replace(
      "import { LucideIcon } from 'lucide-react';",
      `import { LucideIcon, ${config.icon} } from 'lucide-react';`
    );
  }

  fs.writeFileSync(catalogPath, catalogContent);
  console.log(`    ‚úì Adicionado ao cat√°logo`);
}

// Run
generateProduct().catch((error) => {
  console.error('‚ùå Erro:', error);
  process.exit(1);
});

